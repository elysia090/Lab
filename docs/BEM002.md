BEM v0.0.1 – Boolean Expert Machine
Self-Improving MoE Virtual Machine (Normative Default Profile)
(Integrated English ASCII Draft, no separators)
	0.	Scope

0.1 Purpose

This document defines BEM v0.0.1 as a fully specified, self-improving mixture-of-experts (MoE) virtual machine. v0.0.1 is a concrete default profile: all constants, algorithms, and components are fixed. Any compliant implementation MUST implement exactly this profile.

BEM v0.0.1 consists of:
	1.	A deterministic bit-sliced VM core with a fixed integer/bitwise ISA.
	2.	A fixed-size PROGRAM table containing experts and system routines.
	3.	A unified bandit-based SELECTOR core used for expert routing, task selection, and workload scheduling.
	4.	Hash-and-bucket routing from contexts to small candidate sets.
	5.	A structural optimization pipeline using PATCH + VC + PoX with fixed formulas.
	6.	A minimal TEACH subsystem that supplies a closed task set and updates curriculum.

0.2 Fixed global constants

The following constants are fixed for v0.0.1:
	•	N_STATE_BITS = 256
	•	W_LANES = 64
	•	N_SHARED_WORDS = 4096          // 64-bit words
	•	N_PARAMS = 256                  // scalar parameters in SHARED
	•	N_PROGRAM_SLOTS = 256
	•	N_SELECTOR_SLOTS = 16
	•	N_EXP_BUCKETS = 256
	•	N_TASK_BUCKETS = 64
	•	N_SCHED_BUCKETS = 16
	•	MAX_BUCKET_CANDIDATES = 8
	•	MAX_PATCH_QUEUE = 64            // max pending patches

Numeric representations:
	•	All scalar integers are 64-bit signed or unsigned as appropriate.
	•	All probabilities, losses, advantages, and PoX weights in [−8, 8] are stored in fixed-point Q16.16:
	•	Represented as 32-bit signed integers.
	•	Value v_real = v_fixed / 2^16.

These choices are normative for v0.0.1.

0.3 Time scales
	•	Step: single environment step.
	•	Episode: up to H ≤ 256 steps.
	•	Patch: structural change event.

Fast-path constraints apply at step scale only.
	1.	Memory Layout

1.1 Segments

Memory is conceptually partitioned into segments with fixed sizes:
	1.	STATE
	•	Bit-sliced core state.
	•	STATE[0..N_STATE_BITS-1], each entry is a 64-bit word representing W_LANES bits.
	2.	SHARED
	•	4096 64-bit words: SHARED[0..4095].
	•	Subranges are reserved:
	•	[0..255]: scalar parameters Θ (N_PARAMS words).
	•	[256..511]: global counters (steps, episodes, etc).
	•	[512..1023]: env configuration and state.
	•	[1024..2047]: selector statistics and indices.
	•	[2048..3071]: TEACH statistics.
	•	[3072..4095]: WORK / PoX / scratch.
	3.	PROGRAM
	•	Array PROGRAM[0..N_PROGRAM_SLOTS-1] of descriptors, plus a linear code array CODE[].
	4.	SELECT
	•	Array SELECTOR[0..N_SELECTOR_SLOTS-1] plus bandit tables.
	5.	TRACE
	•	Append-only log buffer in stable storage (logical, not addressed here as RAM).
	6.	PROOF
	•	Storage backing the VC solver. Logical here; actual solver implementation is external.

No other segments exist in v0.0.1.

1.2 STATE lane convention

Lane index l ∈ {0..W_LANES-1}.
Bit k of lane l is:
	•	bit_l(s_t[k]) = (STATE[k] >> l) & 1.

1.3 PROGRAM descriptor

PROGRAM[i] has the following fixed layout in SHARED (pseudo-struct):
	•	id_prog: 32-bit integer (unique within [0, N_PROGRAM_SLOTS)).
	•	kind: 8-bit tag (0=unused, 1=expert, 2=env_step, 3=task_template, 4=patch_synth, 5=pox_eval, 6=aux).
	•	entry_pc: 32-bit offset into CODE.
	•	io_state_start: 16-bit index into STATE (first bit), or 0xFFFF if no STATE access.
	•	io_state_len: 16-bit count of bits accessed.
	•	io_shared_start: 16-bit index into SHARED.
	•	io_shared_len: 16-bit count of words accessed.
	•	cost_bound_cycles: 32-bit upper bound on cycles for this PROGRAM.

Every slot is always present; unused slots have kind=0.

In v0.0.1:
	•	All experts have cost_bound_cycles ≤ 512.
	•	env_step PROGRAM has cost_bound_cycles ≤ 1024.
	•	patch_synth and pox_eval PROGRAMs have cost_bound_cycles ≤ 32768 (not called on fast path).

	2.	SELECTOR Core

2.1 SELECTOR descriptor

There are exactly three SELECTORs in v0.0.1:
	•	SELECTOR[0] = ExpertSelector
	•	SELECTOR[1] = TaskSelector
	•	SELECTOR[2] = SchedulerSelector

Each SELECTOR[j] has:
	•	id_sel: j (0,1,2).
	•	role: 0=expert, 1=task, 2=scheduler.
	•	key_bits: 32 (keys are 32-bit).
	•	n_buckets: N_EXP_BUCKETS for role=expert, N_TASK_BUCKETS for role=task, N_SCHED_BUCKETS for role=scheduler.
	•	bucket_offset: offset into SHARED where index entries start.
	•	bandit_offset: offset into SHARED where bandit tables for this selector start.
	•	alpha_fixed: Q16.16 = 1.0 * 2^16.
	•	beta_fixed: Q16.16 = 0.5 * 2^16.
	•	eta_z_fixed: Q16.16 = 0.01 * 2^16.
	•	z_min_fixed: Q16.16 = −4.0 * 2^16.
	•	z_max_fixed: Q16.16 = +4.0 * 2^16.
	•	temp_fixed: Q16.16 = 0.25 * 2^16 (for softmax; still normative).

These values are fixed.

2.2 Bandit state layout

For each SELECTOR[j], each bucket b ∈ [0, n_buckets-1], and each candidate index c ∈ [0, MAX_BUCKET_CANDIDATES-1]:
	•	arm_prog_id[j][b][c]: 32-bit PROGRAM id, or 0xFFFFFFFF meaning empty.
	•	visits[j][b][c]: 32-bit unsigned int, initially 0.
	•	loss_sum[j][b][c]: 32-bit signed Q16.16.
	•	loss_sq_sum[j][b][c]: 32-bit signed Q16.16.
	•	z[j][b][c]: 32-bit signed Q16.16 (log-weight), initially 0.

A global per-selector counter:
	•	N_total[j]: 64-bit unsigned total selection count, initially 0.

2.3 Loss and reward mapping

For every selector, rewards r_real are mapped to losses in [0,1] using fixed ranges:
	•	ExpertSelector (j=0): r_step ∈ [−1, +1]
loss = (1.0 − r_step) / 2.0
→ r_step=+1 → loss=0; r_step=−1 → loss=1.
	•	TaskSelector (j=1): r_task ∈ [−1, +1], same mapping.
	•	SchedulerSelector (j=2): r_sched ∈ [−1, +1], same mapping.

Fixed-point:

// Inputs are Q16.16
loss_fixed = ((1<<16) - r_fixed) / 2

Clamped so that 0 ≤ loss_fixed ≤ 1<<16.

2.4 Bandit index (normative)

Given selector j, bucket b, candidate c:
	1.	n = max(1, visits[j][b][c])
	2.	L = loss_sum[j][b][c]
	3.	Q = loss_sq_sum[j][b][c]
	4.	hat_l_fixed = L / n                // integer division
	5.	var_fixed = max(0, Q / n - (hat_l_fixed * hat_l_fixed >> 16))

Let:
	•	N_k = max(1, N_total[j])

Compute:
	•	logN_fixed = approx_log1p_fixed(N_k)
where approx_log1p_fixed is a fixed piecewise-linear approximation to log(1+N), Q16.16.

Then:
	•	bonus1_fixed = alpha_fixed * sqrt_fixed( (2 * var_fixed * logN_fixed) / n )
	•	bonus2_fixed = alpha_fixed * (3 * logN_fixed) / n
	•	bonus_fixed = bonus1_fixed + bonus2_fixed

Prior:
	•	prior_fixed = −beta_fixed * z[j][b][c] >> 16

Index:
	•	index_fixed = hat_l_fixed - prior_fixed + bonus_fixed

SELECTOR chooses the arm with minimal index_fixed. Ties are broken by smallest c index.

sqrt_fixed and approx_log1p_fixed are deterministic Q16.16 routines with bounded error but MUST be monotone increasing and MUST map non-negative inputs to non-negative outputs.

2.5 UPDATE rule

When a selector j used bucket b and candidate c with observed reward r_fixed:
	1.	loss_fixed = ((1<<16) - r_fixed) / 2
	2.	visits[j][b][c] += 1
N_total[j] += 1
	3.	loss_sum[j][b][c] += loss_fixed
loss_sq_sum[j][b][c] += (loss_fixed * loss_fixed) >> 16
	4.	avg_l_fixed = loss_sum[j][b][c] / max(1, visits[j][b][c])
	5.	// z update: push low-loss arms up
delta_z_fixed = −(eta_z_fixed * (avg_l_fixed - (1<<15))) >> 16
// reference loss = 0.5 → 1<<15
	6.	z_new = z[j][b][c] + delta_z_fixed
if z_new < z_min_fixed then z_new = z_min_fixed
if z_new > z_max_fixed then z_new = z_max_fixed
z[j][b][c] = z_new
	7.	Routing and Contexts

3.1 Hash function

BEM v0.0.1 uses a fixed 32-bit hash Hash32:

Input: 128-bit value (two 64-bit words)
Output: 32-bit integer.

Algorithm:

// Inputs: u64 a, b
x = a ^ (b * 0x9E3779B185EBCA87)
x ^= x >> 33
x *= 0xC2B2AE3D27D4EB4F
x ^= x >> 29
x *= 0x165667B19E3779F9
x ^= x >> 32
return lower 32 bits of x

3.2 Step context F_ctx_step

F_ctx_step uses:
	1.	First 64 bits of STATE:
	•	word0 = STATE[0]
	•	word1 = STATE[1]
	2.	A 64-bit step counter:

	•	step_counter = SHARED[256] (incremented every step).

Context fields:
	•	c0 = word0
	•	c1 = word1 ^ step_counter

Key:
	•	k_step = Hash32(c0, c1)           // 32-bit key
	•	b_exp = k_step mod N_EXP_BUCKETS  // bucket index 0..255

3.3 Task context F_ctx_task

F_ctx_task uses:
	•	task_success_fixed = SHARED[257]   // Q16.16 moving avg success for current task family
	•	task_regret_fixed = SHARED[258]    // Q16.16 regret proxy
	•	difficulty_hint = SHARED[259]      // small integer 0..7

Form 128-bit:
	•	a = (u64(task_success_fixed) << 32) | u64(task_regret_fixed & 0xFFFFFFFF)
	•	b = (u64(difficulty_hint) << 32) | u64(N_total[0] & 0xFFFFFFFF)

Key:
	•	k_task = Hash32(a, b)
	•	b_task = k_task mod N_TASK_BUCKETS  // 0..63

3.4 Scheduler context F_ctx_sched

Scheduler uses:
	•	recent_pox_fixed = SHARED[260]       // Q16.16 moving avg PoX score delta
	•	backlog_patches = SHARED[261]        // number of pending patches (0..MAX_PATCH_QUEUE)
	•	safety_violations = SHARED[262]      // count in last window (0..2^32-1)

Form 128-bit:
	•	a = (u64(recent_pox_fixed) << 32) | u64(backlog_patches & 0xFFFFFFFF)
	•	b = (u64(safety_violations & 0xFFFFFFFF) << 32) | u64(N_total[2] & 0xFFFFFFFF)

Key:
	•	k_sched = Hash32(a, b)
	•	b_sched = k_sched mod N_SCHED_BUCKETS  // 0..15

	4.	Buckets and Candidate Sets

4.1 EXP_INDEX

For ExpertSelector, buckets are stored starting at SHARED[1024]:
	•	For each b_exp ∈ [0..255]:
	•	arm_prog_id[0][b_exp][0..7] are stored as 8 consecutive 32-bit values, packed into 4 64-bit SHARED words.

Encoding:
	•	SHARED[1024 + b_exp*4 + w] holds two 32-bit prog_ids:
	•	lower 32 bits = arm_prog_id[0][b_exp][2w]
	•	upper 32 bits = arm_prog_id[0][b_exp][2w+1]

Empty slot:
	•	0xFFFFFFFF for prog_id means no candidate.

4.2 TASK_INDEX

For TaskSelector, buckets are stored starting at SHARED[1024 + 256*4 = 2048]:
	•	Same packing scheme: 64 buckets, 8 entries each → 64*4 = 256 words → up to SHARED[2303].

4.3 SCHED_INDEX

For SchedulerSelector, buckets are stored starting at SHARED[2304]:

SchedulerSelector has exactly three arms, assigned constants:
	•	0 = workload_act
	•	1 = workload_synth
	•	2 = workload_verify

For each b_sched, arm_prog_id[2][b_sched][0..2] store these three IDs; entries [3..7] are set to 0xFFFFFFFF.

4.4 Bucket invariants

For all selectors, all buckets, all slots:
	•	If arm_prog_id[j][b][c] equals 0xFFFFFFFF, the entry is ignored.
	•	If two slots in the same bucket have the same non-empty prog_id, the implementation MUST treat them as separate arms (this SHOULD NOT occur in normal operation but is defined).

	5.	Programs and Kinds

5.1 Fixed program IDs

v0.0.1 fixes the following PROGRAM IDs:
	•	0: UNUSED (must always stay empty)
	•	1..63: EXPERT programs
	•	64: ENV_STEP program
	•	65..95: TASK_TEMPLATE programs (TEACH tasks)
	•	96: PATCH_SYNTH program
	•	97: POX_EVAL program
	•	98..255: reserved for future patterns; MUST be set unused in v0.0.1

5.2 EXPERT behavior

Experts 1..63 implement small local transformations. v0.0.1 does not prescribe their individual logic but prescribes bounds:
	•	Each expert may only access STATE bits 0..127 and SHARED words 512..767.
	•	Each expert MUST terminate within cost_bound_cycles ≤ 512.
	•	Each expert MUST be implemented using only:
	•	scalar integer ops,
	•	bit-sliced ops,
	•	HASH_CALL and LOG_CALL.

No expert may call PROOF_CALL or TEACH_CALL.

5.3 ENV_STEP program (id=64)

This PROGRAM:
	•	Reads env state from SHARED[512..639].
	•	Reads rewards and done flags from env internal representation.
	•	Writes env state back to SHARED[512..639].
	•	Writes step reward r_step_fixed to SHARED[263] (Q16.16, clamped to [−1,1]).
	•	Writes done flag to SHARED[264] (0 or 1).

cost_bound_cycles(64) ≤ 1024.

5.4 TASK_TEMPLATE programs (id=65..95)

Each TASK_TEMPLATE program:
	•	Implements a specific task (BaseProblem or composition).
	•	When called, it:
	1.	Writes env parameters into SHARED[512..639].
	2.	Writes horizon H (1..256) into SHARED[265].
	3.	Writes task_family_id (0..31) into SHARED[266].
	4.	Writes difficulty_hint (0..7) into SHARED[259].
	•	Return is by convention through SHARED; no direct return value.

Templates 65..67 are fixed defaults:
	•	65: K-armed bandit task (K=4).
	•	66: parity task over 16 bits.
	•	67: key-value retrieval with 4 pairs and 1 query.

Templates 68..95 are unused in v0.0.1 and MUST be empty.

5.5 PATCH_SYNTH program (id=96)

PATCH_SYNTH reads TRACE and produces candidate PATCH entries into a patch queue in SHARED[270..270+MAX_PATCH_QUEUE*4-1]. Each PATCH occupies 4 words in this default profile and encodes:
	•	target_program_id (32-bit)
	•	patch_type (8-bit)
	•	argument1, argument2 (rest of bits)

v0.0.1 defines only one patch_type=1: expert_weight_reset
	•	Resets bandit stats for a particular expert across all buckets.

PATCH_SYNTH MUST:
	•	Scan TRACE for experts with high loss.
	•	Enqueue at most one PATCH per invocation.

5.6 POX_EVAL program (id=97)

POX_EVAL:
	•	Reads WORK metrics and patch queue.
	•	Computes PoX_score for the first pending PATCH.

In v0.0.1:
	•	PoX_score is non-zero only for expert_weight_reset; it equals a fixed positive constant 1.0 (Q16.16) if the PATCH target has above-average loss; else 0.5.

Implementation details given in section 8.
	6.	Fast-Path Step Loop

6.1 STEP_FAST algorithm

Inputs:
	•	STATE_t, SHARED_t.
	•	Active env_step PROGRAM (id=64).
	•	Active task template id in SHARED[267] (not used directly in step).

Algorithm:
	1.	Increment step counter:
	•	SHARED[256] += 1
	2.	Compute step context:
	•	word0 = STATE[0]
	•	word1 = STATE[1]
	•	c0 = word0
	•	c1 = word1 ^ SHARED[256]
	•	k_step = Hash32(c0, c1)
	•	b_exp = k_step mod N_EXP_BUCKETS
	3.	Build expert candidate list for selector j=0:
	•	candidates[0..7] = arm_prog_id[0][b_exp][0..7]
	4.	Expert selection:
	•	a = CHOOSE(selector=0, bucket=b_exp, candidates)
	•	This returns index c*; expert_prog_id = candidates[c*]
	5.	Expert execution:
	•	Call PROGRAM[expert_prog_id](STATE_t, SHARED_t) → (STATE_mid, SHARED_mid)
	6.	Environment step:
	•	Call PROGRAM[64](STATE_mid, SHARED_mid) → (STATE_{t+1}, SHARED_{t+1}, r_step, done)
r_step_fixed is already written to SHARED[263] inside PROGRAM[64].
	7.	Expert bandit update:
	•	r_fixed = SHARED[263]
	•	loss_fixed = ((1<<16) - r_fixed) / 2
	•	UPDATE(selector=0, bucket=b_exp, arm=c*, loss via r_fixed)
	8.	Logging:
TRACE.append_step(
step_counter = SHARED[256],
task_family_id = SHARED[266],
bucket_id_exp = b_exp,
expert_prog_id = expert_prog_id,
reward = r_fixed,
done = SHARED[264]
)
	9.	If done == 1 or local step count has reached horizon H (SHARED[265]), terminate episode, otherwise continue.

6.2 CHOOSE(selector j, bucket b, candidates)

Algorithm:
	1.	For c in 0..7:
	•	if candidates[c] == 0xFFFFFFFF, skip.
	•	Compute index_fixed[j][b][c] as in section 2.4.
	2.	Let c* be argmin index_fixed[j][b][c] (lexicographically smallest c on ties).
	3.	Return c*.
	4.	Episode Loop and Task Selection

7.1 Episode driver

The runtime repeatedly executes the following:
	1.	Task selection step.
	2.	Episode execution.
	3.	TaskSelector update.

7.2 Task selection
	1.	Build CONTEXT_task as in 3.3.
	2.	Compute k_task and b_task.
	3.	Read candidates from TASK_INDEX[b_task].
	4.	c* = CHOOSE(selector=1, bucket=b_task, candidates).
	5.	template_prog_id = candidates[c*].
	6.	If template_prog_id == 0xFFFFFFFF, use fallback template 65.
	7.	Call PROGRAM[template_prog_id] to configure environment (fills SHARED[512..639], sets H, task_family_id, difficulty_hint).
	8.	Store template_prog_id in SHARED[267] for logging.

7.3 Episode execution
	1.	Reset per-episode counters:
	•	SHARED[268] = 0            // episode_step_counter
	•	SHARED[269] = 0            // episode_return_fixed (Q16.16)
	2.	Loop:
	•	Run STEP_FAST once.
	•	SHARED[268] += 1
	•	SHARED[269] += SHARED[263]  // accumulate rewards
Stop if:
	•	SHARED[264] == 1 (done), or
	•	SHARED[268] == SHARED[265] (horizon H).
	3.	End-of-episode logging:
TRACE.append_episode(
episode_id = global_episode_counter,
task_template = template_prog_id,
task_family = SHARED[266],
return_fixed = SHARED[269],
steps = SHARED[268]
)
	4.	Update global_episode_counter in SHARED[257].

7.4 TaskSelector UPDATE

Compute task-level reward r_task_fixed:
	•	pass = 1 if episode_return_real ≥ pass_threshold else 0;
where pass_threshold_real = 0.0, so:
pass = 1 if SHARED[269] >= 0 else 0.
	•	regret_proxy_fixed updated by:
SHARED[258] = 0.9 * SHARED[258] + 0.1 * max(0, (best_seen_fixed - SHARED[269]))
best_seen_fixed kept separately in SHARED[271] and updated as max.

Define:
	•	r_task_real = (2 * pass - 1) - 0.5 * normalized_regret

Where normalized_regret = min(1, regret_proxy_real), mapped into [0,1].
Then map r_task_real ∈ [−1,1] to r_task_fixed Q16.16.

Then:
	•	Compute k_task, b_task again as in 3.3.
	•	Use the same slot c* as chosen earlier.
	•	Call UPDATE(selector=1, bucket=b_task, arm=c*, reward=r_task_fixed).

	8.	Scheduler and Patching

8.1 Workload types

There are exactly three workloads:
	•	workload_act: run one full episode as in section 7.
	•	workload_synth: run one PATCH_SYNTH invocation.
	•	workload_verify: run one VC+PoX evaluation and possibly apply one patch.

8.2 META_STEP

At patch granularity, the scheduler performs:
	1.	Build CONTEXT_sched as in 3.4.
	2.	Compute k_sched, b_sched.
	3.	Arms are implicitly [0,1,2] for act/synth/verify.
	4.	c* = CHOOSE(selector=2, bucket=b_sched, candidates=[0,1,2,0xFFFFFFFF,…]).
	5.	workload = c*.
	6.	Execute workload unit:
	•	If workload=0: run full episode.
	•	If workload=1: run PATCH_SYNTH.
	•	If workload=2: run VC+PoX for one patch.
	7.	Compute r_sched_fixed:
	•	If workload=0: r_sched_fixed = 0 (scheduler-neutral; learning effect goes into other selectors).
	•	If workload=1:
	•	If PATCH_SYNTH enqueued a new patch and queue not full: r_sched_real = +0.2.
	•	Else r_sched_real = −0.1.
	•	If workload=2:
	•	If a patch was successfully applied: r_sched_real = +1.0.
	•	If a patch was rejected (VC fail or PoX < threshold): r_sched_real = −0.2.
	•	If no patch pending: r_sched_real = −0.1.
r_sched_fixed = r_sched_real * 2^16, clamped to [−1,1].
	8.	UPDATE SchedulerSelector:

	•	Compute k_sched, b_sched again.
	•	UPDATE(selector=2, bucket=b_sched, arm=c*, reward=r_sched_fixed).

8.3 Patch queue representation

Patch queue:
	•	MAX_PATCH_QUEUE = 64 entries.
	•	SHARED[272] holds queue_head (0..63).
	•	SHARED[273] holds queue_tail (0..63).
	•	SHARED[274] holds queue_size (0..64).

Each entry uses 4 words:
	•	entries_base = 275.
	•	For index q ∈ [0..63]:
	•	word0 = SHARED[entries_base + q*4 + 0]
	•	bits 0..31: target_prog_id
	•	bits 32..39: patch_type (0 or 1)
	•	remaining bits unused and zero.
	•	word1, word2, word3: patch-type-specific arguments, zero for v0.0.1.

8.4 PATCH_SYNTH behavior (program 96)

When invoked:
	1.	If queue_size == MAX_PATCH_QUEUE, return without action.
	2.	Scan last 1024 step entries in TRACE and compute average loss per expert (based on reward mapping). Implementation details are free but MUST be deterministic given TRACE.
	3.	Identify the worst expert prog_id in range [1..63].
	4.	Enqueue a patch with:
	•	target_prog_id = that prog_id.
	•	patch_type = 1 (expert_weight_reset).

Queue insertion:
	•	q = queue_tail.
	•	Write patch fields to entry q.
	•	queue_tail = (queue_tail + 1) mod 64.
	•	queue_size += 1.

8.5 VC and PoX for v0.0.1

v0.0.1 defines only one patch type, expert_weight_reset, with fixed VC and PoX:
	1.	VC(Δ): always true (weight reset cannot violate safety).
	2.	PoX_score(Δ):
	•	Let target_prog_id = p.
	•	Let avg_loss_p = average loss of expert p over last 1024 steps (precomputed by POX_EVAL).
	•	Let global_avg_loss = average loss over all experts.
If avg_loss_p > global_avg_loss:
	•	PoX_score_real = 1.0
Else:
	•	PoX_score_real = 0.5
PoX_score_fixed = PoX_score_real * 2^16.

PoX threshold:
	•	PoX_threshold_fixed = 0.75 * 2^16.

Thus, a patch is accepted iff avg_loss_p > global_avg_loss.

8.6 POX_EVAL behavior (program 97)

When invoked:
	1.	If queue_size == 0, do nothing and return.
	2.	Take first patch index q = queue_head.
	3.	Read target_prog_id from entry q.
	4.	Compute avg_loss_p and global_avg_loss from TRACE.
	5.	Compute PoX_score as above.
	6.	If PoX_score_fixed ≥ PoX_threshold_fixed:
	•	Apply patch: reset bandit stats for prog_id p across all ExpertSelector buckets:
For all b_exp, all c:
	•	if arm_prog_id[0][b_exp][c] == p:
	•	visits = 0, loss_sum = 0, loss_sq_sum = 0, z = 0
	•	Log patch application to TRACE.
	7.	In all cases, remove patch from queue:
	•	queue_head = (queue_head + 1) mod 64
	•	queue_size -= 1
	8.	TEACH Subsystem (Default Task Grammar)

9.1 Fixed tasks

v0.0.1 TEACH defines exactly three task templates:
	•	TEMPLATE 65: 4-armed Bernoulli bandit.
	•	TEMPLATE 66: parity task over 16 bits.
	•	TEMPLATE 67: key-value retrieval with 4 entries.

Other templates 68..95 are unused.

9.2 TEMPLATE 65: 4-armed bandit

Behavior:
	1.	On call:
	•	Sample true arm means μ[0..3] from fixed table stored in SHARED[300..303] (Q16.16, default: {0.1, 0.3, 0.7, 0.9}).
	•	Initialize env internal state in SHARED[512..511+N_bandit_state].
	•	Set horizon H=32 in SHARED[265].
	•	Set task_family_id=0 in SHARED[266].
	•	Set difficulty_hint=2 in SHARED[259].
	2.	ENV_STEP uses these μ values and STATE bits modeling chosen arm to output Bernoulli rewards.

9.3 TEMPLATE 66: parity over 16 bits

Behavior:
	1.	On call:
	•	Sample a 16-bit input x from PRNG.
	•	Store x in SHARED[520].
	•	Target parity bit = POPCOUNT(x) mod 2, stored in SHARED[521].
	•	Initialize horizon H=8, task_family_id=1, difficulty_hint=3.
	2.	ENV_STEP presents bits sequentially to the expert logic and rewards correct parity output at end.

9.4 TEMPLATE 67: key-value retrieval

Behavior:
	1.	On call:
	•	Generate 4 keys k0..k3 and values v0..v3, store in SHARED[530..537].
	•	Choose query index q in 0..3, store in SHARED[538].
	•	Horizon H=16, task_family_id=2, difficulty_hint=4.
	2.	ENV_STEP reveals key-value pairs and rewards matching the correct value.

9.5 TEACH_CALL

v0.0.1 TEACH_CALL is a trivial wrapper that selects templates only via TaskSelector:

Input:
	•	domain_id (ignored).
	•	difficulty_hint_in (ignored).
	•	CONTEXT_task (ignored; our system builds its own).
	•	seed (ignored; internal PRNG state used instead).

Algorithm:
	1.	Build CONTEXT_task and call TaskSelector as in 7.2.
	2.	If chosen template_prog_id is 0xFFFFFFFF, use 65.
	3.	Call template_prog_id.
	4.	Return:
	•	template_prog_id.
	•	env configuration implicitly in SHARED.
	•	H and task_family_id read from SHARED.

Thus TEACH is fully defined and has no internal policy independent of BEM in v0.0.1.
	10.	ISA Core

10.1 Registers
	•	x0..x31: 64-bit general-purpose. x0 is hard-wired zero.
	•	pc: 64-bit program counter.
	•	sr: status flags.
	•	seed: PRNG state (64-bit).
	•	b0..b31: 64-bit bitvector registers used for bit-sliced operations.

10.2 Instruction set (subset)

Arithmetic:
	•	ADD rd, rs1, rs2
	•	SUB rd, rs1, rs2
	•	MULLO rd, rs1, rs2        // lower 64 bits of product
	•	AND rd, rs1, rs2
	•	OR rd, rs1, rs2
	•	XOR rd, rs1, rs2
	•	NOT rd, rs1

Shifts:
	•	SHL rd, rs1, imm
	•	SHR rd, rs1, imm
	•	SAR rd, rs1, imm

Loads/stores:
	•	LD rd, [base+imm]      // 64-bit word
	•	ST rs, [base+imm]

Bitvector ops:
	•	BLD bd, [base+imm]
	•	BST bs, [base+imm]
	•	B_AND bd, bs1, bs2
	•	B_OR bd, bs1, bs2
	•	B_XOR bd, bs1, bs2
	•	B_NOT bd, bs1
	•	B_SHL bd, bs, imm
	•	B_SHR bd, bs, imm

Control flow:
	•	BEQ rs1, rs2, offset
	•	BNE rs1, rs2, offset
	•	BLT rs1, rs2, offset
	•	BGE rs1, rs2, offset
	•	JMP offset
	•	JAL rd, offset
	•	RET

PRNG:
	•	RAND rd  // xorshift-style PRNG updating seed

Co-processor:
	•	COP_HASH rd, rs1, rs2   // hash memory at [rs1, rs2] range
	•	COP_LOG rs1, rs2        // log entry
	•	COP_PROOF rs1           // VC queries
	•	COP_TEACH rs1           // TEACH_CALL wrapper

All instructions have fixed cycle costs, but cycle counts are implementation-defined as long as PROGRAM cost_bound_cycles are not exceeded.
	11.	Determinism

BEM v0.0.1 is deterministic given:
	•	Initial STATE and SHARED contents.
	•	Initial seed value.
	•	Any PRNG usage in TEACH and ENV_STEP uses this seed via RAND.

No hidden randomness is allowed.

End of BEM v0.0.1 default profile specification (no optional components).
