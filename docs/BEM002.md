BEM v0.0.1 – Boolean Expert Machine, Hardware-Oriented Core Specification (Tightened Draft)
	0.	Scope and Goals

0.1 Purpose

This document defines the Boolean Expert Machine (BEM) v0.0.1 as a hardware-oriented abstract machine with:
	1.	A finite-state bit-sliced core executing over W logical lanes.
	2.	A set of Boolean experts acting as local state transformers on (s, M).
	3.	A bounded-cost hash-based ROUTE unit for expert candidate selection.
	4.	Online learning and structural updates with verification-gated patches.
	5.	A formal use model for real and synthetic environments.

All fast-path operations are restricted to integer and bitwise primitives. Floating-point operations and neural-network-style primitives are not part of the core model.

0.2 Design goals

BEM v0.0.1 is designed to satisfy:

Goal G1 (finite-state core)
The effective runtime state (s, M, Theta) is finite, with fixed bit-widths for all components determined at configuration time.

Goal G2 (bounded fast-path)
For each time step t, the per-step fast-path cost C_fast is bounded by a constant that depends only on compile-time parameters and not on episode length, log size, or number of experts.

Goal G3 (verifiable evolution)
All structural modifications of experts, CFG, routing, and invariants are applied only via patches Delta that have associated verification conditions VC(Delta) checked by the SAT/Hoare unit.

Goal G4 (synthetic engine)
BEM can operate as an experiment planner and synthetic data engine by generating episodes under constraints, templates, and adversarial task selection.

0.3 Non-goals

BEM v0.0.1 does not specify:
	1.	Binary encoding of instructions.
	2.	Concrete microarchitecture (pipeline depth, cache hierarchy).
	3.	Concrete teacher models for distillation.
	4.	Host OS interaction beyond the abstract notion of “environment”.

0.4 Notation and constants

Logical domains:
	1.	U = {0, 1, …, 2^32 - 1} identifier space.
	2.	N ∈ N state bit count.
	3.	K ∈ N shared memory bit count, K > N.
	4.	W ∈ N, W lanes (SIMD-like width).
	5.	P ∈ N parameter vector dimension.

Design-time constants:
	1.	H ∈ N number of hash functions in ROUTE.
	2.	B ∈ N number of buckets per hash function.
	3.	C_entry ∈ N maximum entries per bucket.
	4.	K_cand ∈ N maximum candidate experts per ROUTE query.
	5.	G_max ∈ N maximum gate or LUT size per expert.
	6.	D_max ∈ N maximum depth for LUT-tree form.
	7.	B_flip ∈ N maximum local circuit edits per mid-path update window.
	8.	n_max, m_max bounds on CNF variables and clauses for SAT/Hoare.

All these constants are fixed at configuration time and reported (Section 13).
	1.	Identifiers and Logical State

1.1 Identifier encoding

Each identifier u ∈ U is encoded as a 32-bit word:

u = [class(6) | ecc(6) | shard(6) | local(14)]

where:
	1.	class ∈ {0, …, 2^6 - 1} is an object class.
	2.	ecc ∈ {0, …, 2^6 - 1} is a parity or ECC field.
	3.	shard ∈ {0, …, 2^6 - 1} is a coarse routing shard index.
	4.	local ∈ {0, …, 2^14 - 1} is a shard-local index.

Define projections:
	1.	class(u) = top 6 bits of u.
	2.	ecc(u) = bits [25..20].
	3.	shard(u) = bits [19..14].
	4.	local(u) = bits [13..0].

Define Gray encoding:

g(u) = u xor (u >> 1)

Define similarity:

sim(u, v) = 32 - HammingDistance(g(u), g(v))

Identifiers are partitioned by class:
	1.	U_expert = {u ∈ U | class(u) = c_expert}
	2.	U_cfg = {u ∈ U | class(u) = c_cfg}
	3.	U_var, U_inv, U_env, etc., for other classes.

The set of allocated identifiers at any time is U_alloc ⊆ U.

1.2 ECC constraints

An ECC coding function:

ECC_encode: {class, shard, local} → ecc

MAY be used to enforce:

ecc(u) = ECC_encode(class(u), shard(u), local(u))

The HASH/ECC unit MUST provide a check:

ECC_valid(u) = [ecc(u) = ECC_encode(class(u), shard(u), local(u))]

Identifiers with ECC_valid(u) = false SHOULD NOT be used in ROUTE or EXPERT tables. Implementations MAY use ecc as a weaker parity bitset; this specification does not constrain ECC schemes beyond bit-width.

1.3 Logical state

Logical state components:
	1.	Global state bits s:
s ∈ {0,1}^N
	2.	Shared memory bits M:
M ∈ {0,1}^K
	3.	Parameter vector Theta:
Theta ∈ Z^P, each entry fixed-width integer (e.g. 32-bit or 64-bit).

The triple (s, M, Theta) uniquely determines the runtime configuration of the machine modulo logs and proof artifacts.

1.4 Slot mapping

For each object class c that is table-backed (e.g. experts, CFG nodes), define:

slot_c: U_c_alloc → {0, …, S_c - 1}

where U_c_alloc = U_alloc ∩ U_c and S_c is the capacity for class c.

Properties:
	1.	slot_c is injective on U_c_alloc.
	2.	slot_c is total on U_c_alloc.
	3.	Reverse mapping slot_c_inv: {0, …, S_c - 1} → U_c ∪ {⊥} MAY be maintained.
	4.	slot_c and slot_c_inv are represented in SHARED memory M (e.g. dense arrays or hash tables).

Rebalancing:

A valid rebalancing step for class c is a mapping:

f_c: U_c_alloc → {0, …, S_c - 1}

such that:
	1.	f_c is injective.
	2.	For all u in U_c_alloc, object contents for u are moved from slot_c(u) to f_c(u).
	3.	All references to u remain via identifier u.

After rebalancing, slot_c is updated to f_c.
	2.	Memory Model

2.1 Segments

The address space is partitioned logically into the following segments:
	1.	STATE segment:
Bit-sliced representation of s over W lanes, stored as words S_pl[0..N-1], each W bits.
	2.	SHARED segment:
Contains M, slot mappings, routing tables, stats, Theta, global counters.
	3.	EXPERT segment:
Array EXPERT_c for each expert class group (possibly single array), indexing expert descriptors.
	4.	CFG/CODE segment:
Array of instructions C[0..L-1], plus CFG metadata for node ranges.
	5.	TRACE/LOG segment:
Append-only region storing episodes, structural patches, and summary indices.
	6.	PROOF segment:
CNF formulas, SAT instances, proof objects, invariants, and Hoare annotations.

Addressing within segments is implementation-defined. BEM ISA instructions operate via abstract descriptors (indices, offsets, descriptors) rather than raw addresses.

2.2 STATE segment layout

STATE is represented as:

S_pl: {0, …, N-1} → {0,1}^W

For each bit index k, S_pl[k] is a W-bit word:

S_pl[k] = (s_0[k], s_1[k], …, s_{W-1}[k])

where s_l ∈ {0,1}^N is the state of lane l.

Lane indexing:
	1.	L = {0, …, W-1}
	2.	For any k and l, bit l of S_pl[k] equals s_l[k].

2.3 SHARED segment layout

SHARED contains at minimum:
	1.	M_bits: K bits of shared memory.
	2.	Theta: integer array of length P.
	3.	Slot tables slot_c and slot_c_inv for relevant classes.
	4.	ROUTE tables (Section 3.3).
	5.	Expert stats (W_i, N_i, local error stats).
	6.	Global counters for logging and patching.

SHARED may also contain:
	1.	Scalar hyperparameters (eta schedules, thresholds).
	2.	Precomputed tables (exp approximations, WP_op maps, etc.).

2.4 EXPERT descriptors

For each expert identifier u ∈ U_expert with slot i = slot_expert(u), define:

EXPERT[i] = (id, R_spec, C_rep, W_spec, stats, weight, flags)

where:
	1.	id = u (identifier).
	2.	R_spec: input selection specification.
	3.	C_rep: circuit representation.
	4.	W_spec: write-back specification.
	5.	stats: integer counters (W_i, N_i, optional extra metrics).
	6.	weight: w_i ∈ Q_fixed, positive fixed-point value.
	7.	flags: small bitfield for metadata (e.g. frozen, safety-critical).

2.5 CFG/CODE segment

Let C[0..L-1] be instructions.

CFG nodes:
	1.	Each v ∈ U_cfg has associated:
1.1 pc_start[v] ∈ {0, …, L}.
1.2 pc_end[v] ∈ {pc_start[v], …, L}.
1.3 Succ(v) ⊆ U_cfg.

CFG invariants:
	1.	Instruction ranges [pc_start[v], pc_end[v]) partition the code or form a covering with explicit edges linking them.
	2.	Edges (u, v) correspond to potential control transfers from end of node u to start of node v.

2.6 TRACE/LOG and PROOF

TRACE/LOG:
	1.	log_index: monotone increasing index k.
	2.	entry_k: serialized representation of:
2.1 Episode fragment or full episode.
2.2 Structural patch Delta.
2.3 Summary statistics.

HASH chain:

H_0 = fixed 256-bit constant
H_{k+1} = Hash(H_k || entry_k)

H_k is stored in protected memory or periodically exported.

PROOF:
	1.	CNF formulas: arrays of clauses, each a bitset pair (pos, neg).
	2.	Proof objects: sequences of steps referencing clauses and variable indices.
	3.	Hoare annotations: mapping v → P_v where P_v is a CNF formula.
	4.	Hardware Modules

3.1 BEM-CORE

BEM-CORE executes the BEM ISA, exposing:
	1.	General-purpose registers REG[0..R-1].
	2.	Program counter pc ∈ {0..L}.
	3.	Status flags (for conditional branches).
	4.	Co-processor control and status registers.

BEM-CORE MUST support issuing co-processor commands and polling their completion with bounded overhead.

3.2 BIT-ALU unit

BIT-ALU operations:
	1.	bit_and(dst, src1, src2): dst = src1 AND src2 (bitwise).
	2.	bit_or, bit_xor, bit_not.
	3.	shift_left/right with constant or per-lane shift.
	4.	rotate_left/right with constant shift.
	5.	vector_popcount: per-lane or total bit count over the W-bit word.
	6.	blend(mask, a, b): result = (mask AND a) OR (NOT mask AND b).

The BIT-ALU execution time per operation is bounded by a constant L_BIT independent of N, K, number of experts, and log size.

3.3 ROUTE unit

ROUTE maintains, for each pair (class, shard), a routing table RT[class][shard]:

RT[class][shard] = {buckets[0..B-1]}

Each bucket is a bounded list:

buckets[b] = [u_0, u_1, …, u_{len_b - 1}]

with 0 ≤ len_b ≤ C_entry.

Insertion policy:

When inserting u into bucket buckets[b] for some (class, shard):
	1.	If len_b < C_entry:
Append u.
	2.	Else:
Evict an entry according to an implementation-defined policy (e.g. minimal weight, oldest timestamp).
Insert u.

ROUTE query semantics:

ROUTE_QUERY(qid, class_filter, shard_filter, K_cand) returns:
	1.	A multiset C_raw of candidate identifiers with |C_raw| ≤ H * C_entry.
	2.	A filtered set C_t of up to K_cand candidates, chosen by similarity.

Algorithm (logical):
	1.	Let class_q = class_filter or class(qid).
	2.	Let shard_q = shard_filter or shard(qid).
	3.	For k = 0..H-1:
3.1 Compute b_k = h_k(qid) in {0..B-1}.
3.2 For each u ∈ RT[class_q][shard_q].buckets[b_k], add u to C_raw.
	4.	For each u ∈ C_raw:
4.1 Compute score(u) = S(sim(qid, u), auxiliary_features).
	5.	Let C_t be the subset of at most K_cand elements of C_raw with highest score(u), breaking ties deterministically.

Constraints:
	1.	Hash functions h_k MUST be computable in constant time per k using bitwise ops.
	2.	The scoring function S MUST be computable in constant time per candidate.
	3.	Total primitive operations per ROUTE_QUERY MUST be bounded by:

C_ROUTE ≤ c1 * H + c2 * H * C_entry + c3 * K_cand

for constants c1, c2, c3 independent of the number of experts.

3.4 SAT/Hoare unit

SAT/Hoare unit parameters:
	1.	n ≤ n_max variable bound.
	2.	m ≤ m_max clause bound.

SAT_CHECK:
	1.	Input: cnf_desc describing a CNF with at most n_max variables and m_max clauses.
	2.	Output: SAT or UNSAT or INVALID.

PROOF_CHECK:
	1.	Input: cnf_desc and proof_desc referencing a purported UNSAT proof.
	2.	Output: ACCEPT if all steps are valid and derive the empty clause, else REJECT.

HOARE_CHECK:
	1.	Input: cfg_desc, annotations_desc mapping CFG nodes to CNFs.
	2.	Output: ACCEPT if for all edges (u, v), P_u = WP_instr(u→v)(P_v) holds; else REJECT.

The total cost per SAT_CHECK and PROOF_CHECK is bounded by constants C_SAT(n, m) and C_PROOF(n, m). For v0.0.1, no explicit asymptotic bound is required beyond n ≤ n_max, m ≤ m_max.

3.5 HASH/ECC unit

Provides:
	1.	hash_block(block) → 256-bit hash.
	2.	hash_chain_update(H_prev, entry) → H_next.
	3.	ECC_encode and ECC_decode for identifiers and small memory blocks.

Merkle tree maintenance for selected regions (e.g. EXPERT table) is provided via:
	1.	merkle_update(leaf_index, new_leaf_hash) → updates internal nodes and root.

3.6 LOG unit

LOG unit operations:
	1.	log_append(entry) → k, H_k
1.1 Serialize entry.
1.2 Compute H_{k+1} = Hash(H_k || entry).
1.3 Write entry and H_{k+1} to TRACE/LOG.
1.4 Return index k and H_{k+1}.

The LOG unit MUST ensure append-only semantics; earlier entries MUST NOT be overwritten by BEM-CORE.
	4.	BEM ISA Semantics

4.1 Base instructions (informal)

Base instructions operate on scalar registers and memory. Their semantics follow conventional integer ISA semantics and are not detailed here.

4.2 BEM-specific instructions (formal view)

Each BEM-specific instruction is defined as a partial function on machine state (STATE, SHARED, EXPERT, CFG, TRACE/LOG, PROOF, pc), possibly invoking co-processors.

Examples:
	1.	BEM_LOAD_STATE dst, addr, lanes

1.1 Reads bits from STATE at indices described by addr for lanes in lanes subset of L.
1.2 Writes them into registers dst (scalar or vector), without modifying STATE.
	2.	BEM_STORE_STATE src, addr, lanes

2.1 Reads from src registers.
2.2 Writes bits into S_pl[k] for specified k and lanes, preserving other lanes.
	3.	BEM_ROUTE_QUERY qid, class_filter, shard_filter, dst_buf, K_cand

3.1 Invokes ROUTE_QUERY as in Section 3.3.
3.2 Writes resulting candidate slots or identifiers into dst_buf in SHARED or registers.
3.3 Does not modify EXPERT or STATE.
	4.	BEM_EXPERT_BATCH exec_desc

4.1 exec_desc encodes:
4.1.1 A small set E_batch of expert slots or identifiers.
4.1.2 Lane masks for each expert.
4.1.3 Mode (all lanes same expert vs lane-specific experts).

4.2 For each expert in E_batch:
4.2.1 R_spec is applied to build per-lane input x, using STATE and SHARED.
4.2.2 C_rep is evaluated bit-sliced with BIT-ALU to produce outputs y.
4.2.3 W_spec is applied with lane masks to update STATE and SHARED.

4.3 The combined effect is a simultaneous application of step_i on relevant lanes.
	5.	BEM_UPDATE_STATS stats_desc

5.1 Adjusts stats (W_i, N_i, local error counts) for a small set of experts.
5.2 Cost is bounded by a constant C_stats per invocation.
	6.	BEM_SAT_CHECK, BEM_PROOF_CHECK, BEM_HOARE_CHECK

6.1 Act as wrappers around SAT/Hoare operations.
6.2 MAY block until completion or schedule completion status.
	7.	BEM_LOG_APPEND log_desc

7.1 Serializes a log entry (e.g. episode fragment, patch).
7.2 Invokes LOG unit.
	8.	BEM_APPLY_PATCH patch_desc

8.1 Applies a previously verified patch Delta:
8.1.1 Update EXPERT descriptors and C_rep.
8.1.2 Update CFG, routing tables, invariants, and slot tables.
8.1.3 Update any associated metadata in SHARED and PROOF.

8.2 Precondition: VC(Delta) has been verified and accepted.
	5.	Expert Semantics and Representations

5.1 Input selection R_spec

R_spec for expert i is a finite collection of selectors:

R_spec(i) = {r_0, …, r_{n_i-1}}

Each r_j specifies how to extract the j-th input bit from (s, M). Minimal form:
	1.	r_j is either:
1.1 A fixed global state index k ∈ {0..N-1}, or
1.2 A fixed shared memory index q ∈ {0..K-1}.

Extensions (optional):
	1.	Derived bits from simple arithmetic or logical combinations of a bounded number of bits.

R_i(s, M) builds x ∈ {0,1}^{n_i} by:

x_j = bit selected by r_j

Constraints:
	1.	n_i ≤ N_in_max, a design-time bound.
	2.	R_spec evaluation must be implementable using ≤ C_R(i) primitive operations per lane, with C_R(i) bounded by a constant depending only on N_in_max.

5.2 Write-back W_spec

W_spec for expert i is a collection of write destinations with masks:

W_spec(i) = {w_0, …, w_{m_i-1}}

Each w_j describes:
	1.	Target: STATE or SHARED.
	2.	Bit index or index expression.
	3.	Update rule (e.g. overwrite, OR, AND with complement).
	4.	Optional lane masks.

Given output vector y ∈ {0,1}^{m_i}, W_i(s, M, y) computes (s’, M’) via a finite sequence of bitwise operations satisfying:
	1.	Only the bits explicitly targeted by W_spec(i) may change.
	2.	Other bits of s and M remain unchanged.

5.3 Circuit forms

C_rep for expert i encodes a total Boolean function:

C_i: {0,1}^{n_i} → {0,1}^{m_i}

Allowed forms:
	1.	ANF form

Each output y_j is represented as:

y_j = XOR over monomials M_jk(x)

where each monomial M_jk is a AND-product of a subset of inputs (possibly empty for a constant term).

Representation:
	1.	For each output j:
1.1 A list of monomials.
1.2 Each monomial is a bitmask over inputs indicating which bits are ANDed.
	2.	ROBDD form

Representation:
	1.	A DAG with nodes labeled by input indices and edges for truth/false branches.
	2.	Unique sink nodes for output bits or bit-vectors.
	3.	Reduced and ordered by a fixed variable order.
	4.	LUT-tree form

Representation:
	1.	A binary tree of depth ≤ D_max.
	2.	Each internal node has:
2.1 A predicate p(x) ∈ {0,1} that depends on a small subset of input bits (e.g. one or a small window).
	3.	Each leaf has a LUT:
3.1 A mapping from a small subset of input bits to an output vector.

Bit-sliced evaluation:
	1.	Evaluate all predicates p at internal nodes as W-bit masks.
	2.	Propagate masks to leaves (per leaf, a mask indicating active lanes).
	3.	For each leaf:
3.1 Evaluate its LUT for active lanes.
3.2 Combine outputs using lane masks and bitwise blends.

Constraints:
	1.	Circuit size |C_rep(i)| ≤ G_max for all experts.
	2.	Evaluation of C_rep(i) on bit-sliced input across W lanes must be implementable using ≤ C_C(i) BIT-ALU operations, with C_C(i) bounded above by a constant depending only on G_max and D_max.

5.4 Safety-critical experts

Experts whose outputs directly affect safety-critical bits (e.g. BAD flags, bounds checks) MAY be marked safety-critical via flags. For such experts:
	1.	U_local_flip MAY be disabled or restricted.
	2.	Structural changes MUST be accompanied by stronger verification conditions.
	3.	Fast-Path Execution

6.1 Per-step algorithm

Given lane states s_t^(l) and shared memory M_t, a single fast-path step performs:

For each step t:
	1.	Observation:
1.1 Compute obs_t = O(s_t, M_t) in {0,1}^{d_O}.
	2.	Query identifier:
2.1 Compute q_t = F_obs(obs_t) ∈ U.
	3.	Routing:
3.1 C_t = ROUTE_QUERY(q_t, class_expert, shard_filter, K_cand).
	4.	Policy:
4.1 Form pi_t over C_t using weights w_i.
4.2 Sample or select expert indices i_t^(l) per lane or per lane group.
	5.	Expert batch:
5.1 Execute BEM_EXPERT_BATCH for selected experts and lanes, updating s_t^(l) and M_t to s_{t+1}^(l) and M_{t+1}.
	6.	Stats:
6.1 Apply BEM_UPDATE_STATS to update counters (W_i, N_i, local errors).

6.2 Observation function O

O: S × {0,1}^K → {0,1}^{d_O} is fixed for a given configuration.

Requirements:
	1.	O MUST be implementable as a fixed sequence of:
1.1 Bit selections from S_pl and M_bits.
1.2 Integer operations on small fields in M_bits and Theta.
	2.	Number of primitive operations for O MUST be bounded by C_obs, a configuration constant.

6.3 F_obs function

F_obs: {0,1}^{d_O} → U maps obs_t to an identifier q_t.

Constraints:
	1.	F_obs MUST be injective on a relevant subset of obs-space, or at least structured to map similar obs to similar identifiers by sim.
	2.	Implementation MUST use:
2.1 Bitwise operations.
2.2 Small integer arithmetic.
	3.	Number of primitive operations for F_obs MUST be bounded by C_F.

Example pattern:
	1.	Set class(q_t) = c_expert.
	2.	Set shard(q_t) = hash_shard(obs_t).
	3.	Set local(q_t) = hash_local(obs_t).
	4.	Set ecc(q_t) = ECC_encode(class, shard, local).

6.4 Fast-path cost bound

Define:

C_fast = C_obs + C_F + C_ROUTE + C_policy + C_expert + C_stats

Where:
	1.	C_ROUTE is the worst-case cost of ROUTE_QUERY.
	2.	C_policy is the cost of policy normalization and sampling.
	3.	C_expert is the cost of BEM_EXPERT_BATCH.
	4.	C_stats is cost of BEM_UPDATE_STATS.

Requirement:

For all steps t, C_fast ≤ C_fast_max, a constant depending only on configuration parameters (N, K, W, H, B, C_entry, K_cand, G_max, D_max, etc.) and not on:
	1.	Episode length T.
	2.	Total number of experts allocated.
	3.	Volume of logs.

Implementations MUST be able to provide a conservative bound C_fast_max.
	7.	Learning: Weights and Local Updates

7.1 Episodes

An episode tau with horizon T has:

tau = ((x_t, a_t, u_t, r_t)_{t=0..T-1}, x_T, s_0, e_0)

where:
	1.	x_t ∈ X is environment observation.
	2.	a_t ∈ A encapsulates internal action, including selected expert indices i_t^(l).
	3.	u_t ∈ U_ext is external action.
	4.	r_t ∈ R is reward.
	5.	s_0 ∈ S initial internal state.
	6.	e_0 ∈ E_env initial environment state.

7.2 Gate weight update U_gate_weight

Define for each expert i:

S_i = {t | expert i was used at step t for at least one lane}

If S_i ≠ ∅, define:

hat_l_i = (1 / |S_i|) * sum_{t ∈ S_i} loss_t

where loss_t is a bounded loss, for example:

loss_t = clip(-r_t, L_min, L_max)

with fixed bounds.

Weight update:

w_i’ = w_i * exp_approx(-eta_t * hat_l_i)

where:
	1.	exp_approx is an approximation implementable by LUT and integer arithmetic.
	2.	eta_t is a learning rate, possibly depending on t, |S_i|, or other stats.

Normalization:

On each candidate set C_t, define:

Z_t = sum_{i ∈ C_t} w_i

If Z_t exceeds a fixed bound Z_max, scale w_i down for i ∈ C_t:

w_i ← w_i / Z_scale

for some constant Z_scale ≥ 1, chosen to maintain numeric stability.

7.3 Local circuit update U_local_flip

For a given episode or a window of steps:
	1.	For each expert i, compute a local error metric err_i based on mispredictions or difference from a teacher.
	2.	Rank potential local edits (monomial toggles, LUT bit flips) by estimated impact on err_i.
	3.	Apply at most B_flip such edits in total across all experts.

Constraints:
	1.	Each edit changes a single bit in C_rep(i) or a small bounded group.
	2.	Edits to safety-critical experts MUST be either:
2.1 Disabled, or
2.2 Followed by a local verification check whose cost is bounded.

7.4 Time-scale constraints
	1.	U_gate_weight MAY be run:
1.1 After each episode.
1.2 Periodically (after fixed number of steps).
	2.	U_local_flip MUST NOT exceed B_flip edits per update window.
	3.	Both U_gate_weight and U_local_flip MUST be scheduled such that fast-path bound C_fast is preserved; heavy updates MUST be deferred to mid-path or slow-path windows.
	4.	Structural Updates and Patches

8.1 Patch structure

A patch Delta is a tuple:

Delta = (Delta_expert, Delta_cfg, Delta_route, Delta_inv, Delta_meta)

where each component describes changes to:
	1.	Delta_expert:
1.1 New experts to allocate.
1.2 Modified experts (C_rep, R_spec, W_spec, stats, flags).
1.3 Retired experts.
	2.	Delta_cfg:
2.1 New CFG nodes and edges.
2.2 Updated pc ranges.
	3.	Delta_route:
3.1 Changes to ROUTE tables (insertions, deletions).
3.2 Changes to shard assignments.
	4.	Delta_inv:
4.1 New or modified invariants and Hoare annotations.
	5.	Delta_meta:
5.1 Adjustments to hyperparameters, scheduling policies, priorities.

8.2 Patch life cycle
	1.	Proposal:
1.1 U_struct_propose analyzes logs and hypotheses H to propose Delta.
	2.	Logging:
2.1 Delta is serialized and logged via LOG_APPEND with a tentative status.
	3.	Verification:
3.1 VC(Delta) is constructed and handed to SAT/Hoare unit.
	4.	Decision:
4.1 If VC(Delta) passes, Delta is marked accepted and becomes eligible for BEM_APPLY_PATCH.
4.2 Otherwise, Delta is rejected and MAY trigger counterexample episodes.

8.3 Splitting example

Given Delta_split as in earlier section, patch elements include:
	1.	new experts e_0, e_1 with ids u_0, u_1.
	2.	modifications to gating conditions or R_spec to test bit b.
	3.	routing table updates to include u_0 and u_1.
	4.	optional deweighting or retirement of original expert.

Verification obligations VC(Delta_split) might include:
	1.	For safety-critical bits, equivalence or refinement constraints.
	2.	For performance properties, no obligation at v0.0.1; left to heuristics.
	3.	Verification Kernel (Details)

9.1 CNF encoding

For a given patch Delta and property phi, a CNF encoding function:

Encode(Delta, phi) → Phi

builds a CNF Phi satisfying:
	1.	Phi is satisfiable iff there exists a state or input violating phi under Delta.
	2.	Alternatively, its negation encodes that phi always holds.

9.2 Hoare transformers

For each op in the BEM ISA, precompute:

WP_op: CNF → CNF

operating over a bounded set of variables, typically:
	1.	Variables corresponding to selected STATE bits.
	2.	Variables representing SHARED flags and indices.
	3.	Auxiliary variables representing intermediate results.

For composite instruction sequences instr(u→v) = [op_1, …, op_k]:

WP_instr(u→v) = WP_op1 ◦ … ◦ WP_opk

9.3 Safety and equivalence conditions

Examples of VC(Delta):
	1.	Safety:
For property BAD = 0, encode:

Phi = Encode(Delta, “exists path where BAD = 1”)

VC(Delta) holds if UNSAT(Phi).
	2.	Equivalence on scope X_scoped:

Let F_old and F_new be Boolean functions representing old and new behavior for given inputs x in X_scoped. Encode:

Phi = Encode(Delta, “exists x in X_scoped with F_old(x) ≠ F_new(x)”)

VC(Delta) holds if UNSAT(Phi).

9.4 Application constraint

BEM_APPLY_PATCH(Delta) MUST NOT modify machine state unless VC(Delta) has been verified as true (safety-preserving) by SAT/Hoare unit, and this fact is recorded in PROOF segment and LOG.
	10.	Formal Use Model

10.1 Environment and transitions

Environment family:

P_env^theta: E_env × U_ext → Dist(E_env × X × R)

Defines the stochastic dynamics of environment state e_t, observation x_t, and reward r_t given external action u_t and parameter theta.

10.2 Policy decomposition

Internal policy Pi_int:

Pi_int: S × X → Dist(A)

External policy Pi_ext:

Pi_ext: S × X → Dist(U_ext)

Task policy Pi_task (optional):

Pi_task: H × history → Dist(Theta_env)

history includes logs of past episodes, patches, verification outcomes.

10.3 Performance metrics
	1.	Uncertainty:
H(H_t | logs up to t), where H_t is random variable over H.
	2.	Regret:
R_T = sum_{t=0}^{T-1} [V*(x_t) - r_t] for appropriate value function V*.
	3.	Safety:
P[ violation of phi_j ] for safety properties phi_j.
	4.	Compute:
C_token average per-step cost, measured in cycles or abstract ops.

BEM aims to keep:
	1.	H(H_t | logs) decreasing over time.
	2.	E[R_T] sublinear in T, where possible.
	3.	Safety violation probabilities below configured thresholds.
	4.	C_token ≤ C_fast_max with heavy computation delegated to synthetic and verification modes.
	5.	Synthetic Data Engine (Details)

11.1 Template structure

Template T_k is represented by:
	1.	A CFG path pi_k = (v_0, …, v_Lk).
	2.	A pattern over observations and rewards along pi_k.
	3.	A set of parameterized positions:

Param_k = {positions where values vary}
	4.	Noise_k capturing stochastic variation.

T_k(theta, z) reconstructs a synthetic episode by:
	1.	Instantiating parameter positions with theta.
	2.	Sampling randomness according to z.
	3.	Executing through the existing expert and CFG structure.

11.2 T_extract procedure (informal)

Given log set L:
	1.	Cluster episodes by CFG paths and high-level statistics.
	2.	For each frequent cluster:
2.1 Identify stable positions (fixed values) and parameter positions.
2.2 Construct template T_k summarizing that cluster.
	3.	Filter templates by coverage and usefulness (e.g. contribution to reducing error or uncertainty).

11.3 CEGIS loop

Counterexample-guided inductive synthesis loop:
	1.	Propose candidate invariant or structural change.
	2.	Encode violation of desired property into CNF.
	3.	Run SAT_CHECK:
3.1 If SAT, obtain counterexample assignment; map to state and generate an episode.
3.2 Use episode to refine hypotheses, experts, or invariants.
	4.	Iterate until UNSAT or resource limits reached.

BEM integrates this loop via:
	1.	U_struct_propose for proposals.
	2.	SAT/Hoare for counterexamples.
	3.	T_extract and synthetic sampling for refinement episodes.
	4.	Scheduling and Resource Allocation

12.1 Resource accounting

Define:
	1.	C_fast_token: cost of fast-path per step.
	2.	C_synth_episode: cost to generate a synthetic episode.
	3.	C_verify_patch: average cost per verified patch.

Define counts over a window:
	1.	N_act: number of real interaction steps.
	2.	N_synth: number of synthetic episodes.
	3.	N_patch: number of patch verifications.

12.2 Adaptive alpha selection

A simple feedback scheduler:
	1.	Maintain moving estimates of:
1.1 Regret on real tasks.
1.2 Uncertainty over H (e.g. empirical entropy from scores).
1.3 Verification backlog (pending patches).
	2.	Adjust alpha_act, alpha_synth, alpha_verify by:
2.1 Increasing alpha_synth when uncertainty is high and backlog low.
2.2 Increasing alpha_verify when backlog high or safety margin low.
2.3 Increasing alpha_act when real performance priority is high and safety stable.

The exact control law is implementation-defined but MUST respect the global constraint alpha_act + alpha_synth + alpha_verify = 1.
	13.	Configuration and Reporting

13.1 Mandatory configuration fields

Implementations MUST specify:
	1.	N, K, W.
	2.	P and Theta bit-width.
	3.	H, B, C_entry, K_cand.
	4.	G_max, D_max.
	5.	B_flip.
	6.	n_max, m_max for SAT/Hoare.
	7.	Maximum number of experts allowed.
	8.	Bounds on STATE and SHARED sizes (bytes).
	9.	Any classes used (class codes for expert, cfg, var, inv, etc.).

13.2 Performance reporting

For any experimental result, the following MUST be reported:
	1.	Hardware:
1.1 CPU model.
1.2 SIMD width.
1.3 Clock frequency (approximate).
	2.	BEM configuration as above.
	3.	For fast-path:
3.1 Average cycles per step or per token.
3.2 Tokens per second per core.
	4.	For tasks:
4.1 Accuracy, regret, or other task-specific metrics.
4.2 Safety violations (if any).
	5.	For verification:
5.1 Average SAT_CHECK and PROOF_CHECK cost.
5.2 Patches proposed, accepted, rejected.
5.3 Ratio of verification cycles to fast-path cycles.

13.3 Versioning

This specification is BEM v0.0.1.

Subsequent versions MAY:
	1.	Tighten complexity bounds for SAT/Hoare.
	2.	Introduce standard reference configurations for benchmark comparability.
	3.	Extend expert representations or routing schemes, preserving bounded fast-path cost.
	4.	Define standardized teacher interfaces for distillation.

	
